## 4.1 제한적 직접 실행이란?

> 이전에 사용자 입장에서 동시에 여러개 프로세스가 동작하는것으로 보이도록 하려면 **CPU 가상화**를 해야한다고 했었다.
> 그런데, 이 가상화 기법을 구현하기위해서는 여러가지 문제점을 해결해줘야 한다.

![image](https://github.com/user-attachments/assets/2d72ce84-9735-4883-b8e8-58f6d45332e9)

이 그림은 기본적인 `제한적 직접 실행` 과정을 나타내는 그림이다. 단순히 가상 주소 공간 할당 -> main() 실행 -> return -> 메모리 해제 과정을 수행한다.
그러나, 이 접근법은 프로세스가 비정상적으로 실행되는 문제가 존재한다. 
예를 들어, 사용자가 프로그램을 직접 실행하면 OS가 원하지 않는 작업(메모리 침범, 할당하지 않았는데 접근하는 등...)을 시도할 가능성이 있다.
따라서 이 문제를 해결하기 위해서는 OS가 프로그램의 실행을 일정부분 통제해야 한다.

## 4.2 문제점 1 : 제한된 연산

![image](https://github.com/user-attachments/assets/1343cc49-bfa3-4959-acb7-fa4adbcadbad)

> 제한된 직접 실행은 운영체제가 프로그램을 효율적으로 실행시키기 위해 사용하는 방법으로,
> 프로그램이 CPU에서 직접 실행되는 동안 운영체제가 프로세스의 제어권을 유지하는 것이 핵심이다.
> 이 과정에서 **트랩**과 **시스템 콜**이 중요한 역할을 수행한다.

`트랩 (Trap)` : 사용자 모드에서 허용되지 않는 작업(입출력, 메모리 할당 등)을 처리하기 위해 커널 모드로 전환되는 과정
`시스템 콜 (System Call)`: 프로세스가 운영체제에게 요청하는 작업의 종류. 입출력, 프로세스 생성, 메모리 할당 등이 이에 포함된다.
`커널 모드와 사용자 모드`: `커널 모드`에서는 운영체제가 시스템의 모든 자원에 접근할 수 있으며, `사용자 모드`에서는 제한된 작업만 허용됩니다. previledge 명령어를 통해 커널 모드로 전환할 수 있다. 

이 제한적 직접 실행 프로토콜을 통해 운영체제는 **성능 저하를 최소화**하면서도 프로세스가 **시스템 자원을 효율적으로 사용**할 수 있도록 제어할 수 있게 된다.

### 그림 설명
1. 부트 시 초기화 (커널 모드):

운영체제는 트랩 테이블을 초기화하고, syscall 핸들러의 주소를 하드웨어에 저장한다. 
이 과정에서 previledge 명령어를 사용해서 하드웨어와 커널 간의 인터페이스가 설정된다.

2. 프로세스 실행 준비 (커널 모드):

사용자 모드로 전환되기 전에 필요한 레지스터 상태를 저장한다.
이후 `return-from-trap` 명령어를 통해 커널 스택의 레지스터를 복원하고, 
`사용자 모드`로 전환해서 프로그램의 main() 함수를 실행한다.

3. 프로세스 실행 중 (사용자 모드):

사용자는 일반적인 연산을 수행한다. 하지만 도중에 시스템 자원에 대한 요청이 필요한 경우(예: 파일 시스템 접근), 
syscall을 호출하여 운영체제에 도움을 요청해야한다.

**이때 트랩이 발생하여 다시 커널 모드로 진입하며, 운영체제가 시스템 콜을 처리한다.**

4. 트랩 처리 (커널 모드):

트랩이 발생하면 커널 스택에 **레지스터 상태를 저장(어디까지 실행했는지)**하고, 
시스템 콜을 처리한 후 다시 return-from-trap 명령어를 사용하여 사용자 모드로 돌아간다.

5. 프로세스 종료 (사용자 모드 → 커널 모드):

프로그램이 종료될 때, 다시 트랩이 발생하여 운영체제는 메모리 해제 등의 종료 작업을 수행한다.

## 4.3 문제점 2 : 프로세스 간 전환

![image](https://github.com/user-attachments/assets/e5963909-619b-4b95-be3d-cf83e2cbb20c)

> CPU 가상화를 위해 프로세스들을 전환해야 하는데, 어떻게 전환해야하는가?. 그리고 나중에 다시 CPU 제어권을 얻으려면 어떻게 해야할까?

### 1. 협력적 접근 방식 - 시스템 콜 기다리기

> 이 방법은 초기 OS에서 사용된것으로, 프로세스들이 합리적으로 행동할 것이라고 신뢰한다고 가정하는 것이다.
> 너무 오랫동안 실행할 가능성이 있는 프로세스의 경우에는 CPU 제어권을 운영체제에 넘겨줄 것이라고 신뢰하는 것이다.

- 만약 프로세스가 시스템 콜을 호출하지 않는 경우에는 Divided by zero 또는 segmentation fault의 경우에 제어권을 OS가 획득할 수 있다.
- 만약 프로세스가 계속 CPU를 양보하지 않는다면, OS는 다시 제어권을 얻을 수 없으므로 시스템이 멈출 수 있다.

때문에 이 방식을 **비선점형**이라고도 부른다.

### 2. 비협력적 접근 방식 - 강제로 제어권 가져오기

> 현대 OS에서는 Timer inturrupt같은 하드웨어 메커니즘을 사용해서 프로세스 실행을 시간이 지나면 **강제로 중지시켜버린다.**
이렇게 하면 OS는 주기적으로 제어권을 획득할 수 있다.

컴퓨터 부팅 시, OS는 하드웨어에 일정한 간격으로 Inturrupt를 발생시키도록 설정한다. 
이 inturrupt가 발생할 때 마다 OS가 제어권을 획득하여, 계속 프로세스를 실행시킬지 아니면 다른거 실행시킬지 결정할 수 있다.

### Context switch

만약 프로세스를 **전환**한다면 현재 실행중인 프로세스의 상태(레지스터 값)을 저장하고, 다음 프로세스의 레지스터 값을 복원해야 한다.
이렇게 해야 각 프로세스마다 중단된 시점에서부터 다시 실행을 이어나갈 수 있다.

> 이 작업을 PCB (xv6에서는 proc)에 레지스터 값을 저장하는 방식으로 관리하고,
> 그림에서 보이는것 처럼 OS는 return-from-trap 명령을 사용해서 이를 수행한다.

**Context switch 개념은 multitask 작업에서 필수적으로 사용되며, 이 행위가 바로 CPU 가상화의 핵심이다.**

## 4.4 병행성
