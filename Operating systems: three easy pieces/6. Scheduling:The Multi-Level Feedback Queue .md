## 11.1 MLFQ의 기본 규칙

- MLFQ는 여러개의 큐로 구성되고, 각각 다른 우선순위를 가진다.
- 따라서 어떤 작업이 특정 우선순위의 큐에 들어가면, 해당 작업은 큐의 우선순위를 가진다.
- 큐에는 당연하게도 두개 이상의 작업이 존재할 수 있고, 동일한 큐에 존재하는 모든 작업은 동일한 우선순위를 가진다.
- 여러개의 작업이 존재하는 큐에서 작업을 선택하는건 Round Robin 방식으로 선택하게 된다.
- MLFQ는 어떤 작업이 CPU를 다른 작업에게 계속 양보하는 경우, 우선순위를 높인다. (I/O interrupt가 많은 작업 -> 대화형 프로세스)
- 반대로 CPU를 집중적으로 사용한다면 우선순위를 낮춘다.

<img width="260" alt="스크린샷 2024-09-29 오후 3 03 51" src="https://github.com/user-attachments/assets/981bd1fe-f523-409b-aaea-ffd2df6bc851">

> 기본 규칙
> 1. 작업 A, B가 있을 때, Priority(A) > Priority(B) 이면 A가 실행된다.
> 2. Priority(A) = Priority(B)이면 Round Robin에 의해 선택되어 실행된다.

## 11.2 우선순위를 변경하는 작업

> 추가 규칙
> 3. **작업이 시스템에 진입하면, 가장 높은 우선순위 큐에 놓는다.**
> 4-a. 주어진 Time slice를 모두 썼다면, 우선순위가 낮아진다(낮은 우선순위 큐로 이동)
> 4-b. 또는 Time slice를 모두 쓰기 전에 CPU를 양도해서 우선순위를 유지한다.

### Example

<img width="306" alt="스크린샷 2024-09-29 오후 3 07 49" src="https://github.com/user-attachments/assets/059d32ad-f6d6-41f6-822a-c9805aebdc54">

만약 세개의 우선순위 큐를 가진 MLFQ에서 하나의 긴 작업이 들어왔다면? 다음과 같이 동작한다.

1. 주어진 Time slice만큼 Q2에서 실행 -> 우선순위가 낮아져서 Q1으로 이동
2. 주어진 Time slice만큼 Q1에서 실행 -> 우선순위가 낮아져서 Q0으로 이동
3. 가장 낮은 우선순위 큐이므로 계속 Q0에 존재하며 실행됨

### I/O Task Problem


