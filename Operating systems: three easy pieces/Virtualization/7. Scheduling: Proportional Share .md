> 비례 배분 (공정 배분) - Proportional Share : 반환 시간이나 응답 시간을 최적화하는 대신, 스케쥴러가 각 작업에게 CPU의 일정 비율을 보장하는 것
>
> 이에 대한 좋은 예시로, 추첨 스케쥴링(Lottery Scheduling)이라는 기법이 존재한다.


## 7.1 Lottery scheduling 기본 개념

> Time slice (Time quantum)이 끝날 때 마다 확률적으로 Ticket을 선택하는 방식

이 스케쥴링 기법의 근간 : **추첨권(Ticket)**

**추첨권이란?** 프로세스가 받아야할 자원의 몫을 나타내는데 사용됨.
- 전체 티켓에 대한 프로세스가 소유한 티켓의 개수의 비율 = 자신의 몫

### Example

프로세스 A, B가 있을 때, A는 75장의 Ticket, B는 25장의 Ticket을 보유한 상태
- A에게는 75%의 CPU를 할당하고, B에게는 25%의 CPU를 할당해주어야 한다.

### How?
> 추첨 스케쥴링은 이 목적을 확률적으로 달성한다.

- 추첨권이 총 100장 존재
- A는 0 ~ 74번까지의 Ticket
- B는 75 ~ 99까지의 Ticket

확률적으로 0~99까지의 티켓을 뽑았을 때 다음과 같은 결과가 나왔다면,
![image](https://github.com/user-attachments/assets/b43d3451-71fc-4093-b96a-0b8f02c19d3a)

그에 따른 스케쥴링 결과는 당연하게도,
![image](https://github.com/user-attachments/assets/a1182ffa-87c2-4216-9a7b-579a2cd1306d)

근데 이렇게 무작위로 뽑게 되면 원하는 비율을 정확히 보장하지 못하는것을 볼 수 있다. (80:20)
물론, 횟수가 많아질수록 (프로세스가 오래 실행될수록) 확률에 근접하긴 할것이다.

## 7.2 추첨 기법

### 1. Ticket currency (추첨권 화폐) 기법

> 사용자가 추첨권을 자신의 화폐 가치로 티켓을 마음대로 할당할 수 있게 허용하는 방법

- 시스템은 자동적으로 지역 화폐 가치를 **글로벌 화폐 가치**로 변환해준다.

#### Example

총 Global Ticket 개수 : 200장
- User A : 100장의 Ticket, $A_{1}, A_{2}$ 두개의 작업을 수행중이다.
- User B : 100장의 Ticket, $B_{1}$ 한개의 작업을 수행중이다.

여기서 User A는 임의로 자신의 지역 화폐 가치로 변환해서,
총 지역 화폐(티켓) 개수를 1000장으로 정하고,
각 프로세스 $A_{1}$에게 500장, $A_{2}$에게 500장을 나누어 주었다.
- **그렇다면 이 지역 화폐가 Global ticket으로 변환될때, $A_{1}$ : 50장 $A_{2}$ : 50장 으로 변환된다.**

또한, User B도 임의로 자신의 지역 화폐를 사용해서
총 지역 화폐(티켓) 개수를 10장으로 정하고,
$B_{1}$에게 10장을 모두 주었다면,
- **Global Ticket으로 변환 시 100장의 Ticket으로 변환된다**

### 2. Ticket transfer (추첨권 양도) 기법

> 한 프로세스가 다른 프로세스에게 일시적으로 Ticket을 빌려주는 기법

#### Example
- Client-server 환경에서 유용하게 사용한다.
  1. Client 프로세스는 Server에게 메세지를 보내서 특정 작업을 해달라고 요청
  2. 특정 작업을 빨리 수행할 수 있도록 서버에게 **Ticket을 양도해서 서버의 성능을 극대화**
  3. 특정 작업이 완료되면 다시 양도한 Ticket을 **되돌려준다**

### 3. Ticket inflation (추첨권 팽창) 기법

> 프로세스는 일시적으로 자신이 소유한 Ticket 개수를 늘리거나 줄일 수 있다.
예를 들어, 더 많은 CPU 점유가 필요하다면 ticket 수를 늘릴 수 있다.

#### Example

- 프로세스들이 상호 신뢰 상태일 때 유용하게 사용할 수 있다.
- **욕심이 많은 프로세스 (CPU 점유를 계속해서 수행하는 프로세스)가 프로세스를 점유하기 위해,
  많은 양의 ticket을 자신에게 할당하는 시스템에서는 (비신뢰적인 시스템) 적용 불가**
  
## 7.3 구현
```c
// counter: 당첨자를 발견했는지 추적하는 변수
int counter = 0;

// winner: 0부터 총 추첨권 수 사이의 임의의 값을 얻기 위해 난수 발생기 호출
int winner = getrandom(0 , totaltickets);

// current: 작업 목록 탐색하는데 사용하는 링크드리스트 노드
node_t *current = head;

// 티켓값 > winner를 만족할 때 까지 반복한다.
while (current) {
  counter = counter + current−>tickets;
  if (counter > winner)
    break; // 당첨자 발견
  current = current−>next;
}
// current는 당첨자를 가리킨다.
```

예를 들어, 다음과 같이 작업이 있다고 해보자.
![image](https://github.com/user-attachments/assets/bc382995-665a-492e-a17d-be19f6443164)
코드가 어떻게 실행되냐면,

1. 프로세스 리스트(그림)을 순회하면서 counter 값이 winner 값을 초과할 때 까지 **각 작업의 추첨권 개수(Tix)를 counter에 더한다**
2. 값이 초과한다면, 리스트의 현재 원소가 당첨자가 된다.

만약 winner = 300이라면
A->Tix = 100 이므로 **counter = 100** -> 아직 winner보다 작으니까 loop
B->Tix = 50 이므로 **counter = 150** -> 아직 winner보다 작으니까 loop
C->Tix = 250 이므로 **counter = 400** -> winner보다 크므로 stop, **current = 프로세스 C를 가리키고 종료된다**

## 7.4 Linux scheduling - CFS (강의 내용)

> 리눅스의 CFS(Completely Fair Scheduler)는 각 프로세스에 **공평하게** CPU 시간을 나누어주는 것을 목표로 한다.

- 전통적인 방식과 다르게, CFS는 프로세스의 우선순위를 기반으로 CPU 시간을 할당하는 것이 아니라, **공평한 CPU 시간 분배**를 추구한다.

### CFS의 핵심 개념

![image](https://github.com/user-attachments/assets/1fd5615e-d849-42f7-9701-890ccda06d4f)

#### 우선순위 기반 스케쥴링
   - 리눅스 커널 2.5 이후, CFS는 모든 프로세스에 공평하게 CPU 시간을 주는 방식으로 동작한다.
   > 기존 2.4버전까지의 tasc_struct 구조체에서는 priority 값을 사용했으나, 이후 coutner와 nice로 바뀌게 된다.
   - 하지만 여전히 **우선순위**라는 개념은 존재한다. 리눅스에서는 **우선순위 값**이 낮을수록 중요한 작업을 의미하며, **실시간 작업은 0~99번, 일반 작업은 100~140번 우선순위 값**을 갖는다.
   - 높은 우선순위(값이 낮은 프로세스)가 더 긴 **Time quantum**을 할당받아서 CPU 점유를 더 많이 할 수 있다.

    **여담**
     > 왜 priority를 nice로 변경했을까?
     > nice 시스템콜 : 자기의 우선순위를 낮추는 시스템콜
     > 주변 프로세스는 이걸 보고 **nice!**라고 생각하게 되므로 이렇게 만들었다고 한다...
    
#### CPU 시간의 공평성
   - CFS는 각 프로세스에게 **공평한** CPU 시간을 할당하려는 스케쥴링 기법이다.
   - 따라서 각 프로세스가 CPU를 사용한 시간을 기록하고, 각 프로세스가 얼마나 공평하게 CPU 시간을 소비하고 있는지를 기준으로 더 많은 CPU 시간을 줄지, 덜 줄지를 결정하게 된다.
   - 만약 프로세스 A가 10ms 동안 CPU를 사용했고, 프로세스 B는 5ms만 사용했다면, CFS는 B에게 더 많은 CPU 시간을 할당해 공평하게 시간을 나누려 한다.
   
#### 타임 퀀텀(Time Quantum)
   - 프로세스는 CPU에서 실행될 때, 일정 시간 동안만 CPU를 사용하다가 다시 스케줄러에 의해 중단되고 다른 프로세스에게 CPU가 넘어간다.
   - 이 시간을 **Time quantum**이라고 하는데, CFS는 이 시간을 공평하게 조정해서, 각 프로세스가 공평하게 CPU 시간을 사용할 수 있도록 조정한다.
   - 
#### 짧은 수면 (short sleep)
   - 프로세스가 잠깐 동안만 중단되었다가 다시 실행되는 상황을 CFS가 고려한다.
   - 만약 프로세스가 잠시 동안만 **sleep** 상태에 있다가 다시 깨어났다면, CFS는 이 프로세스가 오래 대기하지 않도록 CPU 시간을 배려해준다. 
   > 예를 들어, 프로세스 C가 잠시동안 I/O 작업을 기다리다가 다시 CPU에 돌아왔다고 해보자.
   > CFS는 이를 인식해서 C가 오래 기다리지 않도록 다시 빨리 CPU 시간을 할당해준다.

#### 공평성 기반 보너스 시간
   - 짧게 잠든 작업에게 보너스 시간을 부여할 수 있다.
   - 하지만 이 보너스 시간은 **CPU를 계속 사용한 작업보다 유리하지 않게** 설계되어 있다.
   - 따라서 시스템 전체적으로 **공평성을 유지할 수 있다.**
   
#### 필요한 만큼만 CPU 사용
   - CFS의 핵심 목표는 프로세스가 CPU를 꼭 필요한 만큼만 사용하게끔 만드는 것이다.
   - 다시 말해, 불필요하게 긴 시간 동안 한 프로세스가 CPU를 점유하지 않도록 관리해야 한다.

### Example

- **프로세스 A**는 실시간 작업으로 우선순위가 매우 높고, CPU에서 오랫동안 실행된다.
- **프로세스 B**는 일반적인 작업으로, CPU가 필요하지만, 중간중간에 짧은 I/O 작업으로 잠시 sleep 상태로 전환된다.
- **프로세스 C**는 비슷한 작업을 수행하는 일반 프로세스이다.

1. CFS는 이 3개의 프로세스가 공평하게 CPU를 사용하도록 조정한다.
2. 프로세스 A는 높은 우선순위 때문에 상대적으로 긴 CPU 시간을 받을 수 있다.
3. 하지만, CFS는 B와 C가 A 때문에 CPU 시간을 못 쓰지 않도록 관리한다.
4. 특히, B가 잠시 sleep했다가 돌아오면, CFS는 B가 오랫동안 기다리지 않도록 CPU 시간을 할당해준다.

이를 통해서 각 프로세스가 **필요한 만큼만 CPU를 사용**하며, 시스템 전체의 성능과 효율성을 최적화할 수 있게 된다.

