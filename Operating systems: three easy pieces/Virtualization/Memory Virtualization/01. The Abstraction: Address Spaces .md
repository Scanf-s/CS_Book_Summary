## 1.1 초기의 메모리 시스템

![image](https://github.com/user-attachments/assets/0bf43d9c-fbfa-4f24-96d9-7a9ebff421a8)

초기에는 위 그림처럼 물리 메모리에 운영체제를 제외한 나머지 영역에 **하나의 프로세스**만 올라갈 수 있었다.

## 1.2 멀티프로그래밍, 시분할의 등장

![image](https://github.com/user-attachments/assets/d3f65676-2d48-4ed2-b2e3-c6fbeddbd1b1)

> 멀티 프로그래밍 : 여러 프로세스가 실행 준비 상태에 있고, 운영체제는 이 프로세스들을 전환하면서 실행하는 것

- 예를 들면, 한 프로세스가 I/O interrupt가 걸렸을 때, CPU가 다른 프로세스를 선택해서 처리하는 것을 의미한다.
- 이러한 context switch를 통해 CPU의 이용률이 늘게되어 **효율적인 자원 사용**이 가능하게 되었다.

> 시분할 : 하나의 프로세스를 짧은 시간 동안 실행시키는 것

- 프로세스는 자신에게 주어진 시간동안 CPU 점유가 가능하다.
- **시간을 다 소진한다면, 중단 시점의 모든 프로세스의 상태를 디스크 종류의 장치에 저장하고, 다른 프로세스의 상태를 다시 가져와서 실행시킨다.**

**위 방법의 문제점**
- 너무 느리게 동작한다. (메모리가 커질수록 느리게 동작한다)
- 디스크 종류의 장치에 데이터 I/O를 수행하므로 매우 느리기 때문

## 1.3 가상 주소 공간

> 실제 메모리 공간이 아니라, 각 프로세스마다 가지게 되는 **가상 주소 공간**이다.
> 가상 주소 공간을 이해하는것이 Memory virtualization을 이해하는것이라고 한다.

### 가상 주소 공간 구조

0. unused 영역 : null pointer 역할 (올바르지 않은 메모리 영역 역할을 수행)
1. text 영역 : 프로그램의 코드가 탑재되는 메모리 영역
2. data 영역 : 전역 변수를 다루는 영역
3. heap 영역 : 동적 할당 시 채워지는 메모리 영역
4. stack 영역 : 함수 호출 체인, 지역 변수, 함수 인자 및 반환값에 대한 영역

![image](https://github.com/user-attachments/assets/ec3deeb7-8fc6-4d0a-a538-d53589397088)
> 출처 : https://wayhome25.github.io/cs/2017/04/13/cs-15-1/

### 메모리 가상화

> OS가 메모리를 가상화 한다는것 = 프로세스가 자신은 실제 특정 주소의 메모리에 탑재되고, 큰 주소 공간을 가지고 있다고 생각하게끔 착각하게 만드는 것. 당연하게도, 실제로는 그렇지 않다.

**메모리 가상화의 목표**
1. 투명성 - OS는 프로세스가 가상 메모리의 존재를 인식하지 못하도록 구현해야 한다.
2. 효율성 - 가상화를 사용하더라도 너무 느려서도 안되며, 가상화를 위한 공간도 많이 차지해서는 안된다.
3. 보호 - 프로세스를 다른 프로세스로부터 보호해야 하고, OS 자신도 보호받아야 한다. (고립)

> **C언어에서 보는 모든 주소는 사실 가상 주소이다**


