## 4.1 세그멘테이션: 일반화된 Base/Bounds
**세그멘테이션(segmentation)**은 주소 공간의 각 논리적 세그먼트마다 **base**와 **bounds** 레지스터를 가지고, 물리적 메모리에 이를 독립적으로 배치하는 방식입니다. 

세그멘테이션에서는 주소 공간을 여러 개의 **세그먼트(segment)**로 나눕니다. 여기서 세그먼트는 **코드(code)**, **스택(stack)**, **힙(heap)**으로 구분되며, 각 세그먼트는 서로 다른 역할을 담당하는 연속된 메모리 공간입니다.

#### 1. 물리적 메모리의 세그먼트 배치

![image](https://github.com/user-attachments/assets/f73d2c6b-5cd4-4450-a94a-2dc3bb1ab89d)

위 그림은 가상 주소 공간의 구성을 보여줍니다. 코드, 힙, 스택으로 나뉘어 있으며, 각 부분은 프로그램 코드, 동적 메모리 할당(힙), 함수 호출을 위한 스택으로 나누어져 있습니다.

가상 주소 공간을 물리적 메모리에 배치할 때, 각 세그먼트를 물리 메모리의 서로 다른 위치에 배치할 수 있습니다. 아래 그림은 이러한 세그먼트들이 어떻게 물리적 메모리에 배치되는지 보여줍니다.

![image](https://github.com/user-attachments/assets/5866ae08-be3c-49c7-bc83-2f673f0b02fd)

#### 2. 세그멘테이션 하드웨어 구조
세그멘테이션을 지원하는 하드웨어 구조는 **base**와 **bounds** 레지스터 쌍을 세 개(코드, 스택, 힙) 가지고 있어야 합니다.

아래는 각 세그먼트의 레지스터 값을 보여주는 표입니다.

| Segment | Base | Size |
|---------|------|------|
| Code    | 32K  | 2K   |
| Heap    | 34K  | 2K   |
| Stack   | 28K  | 2K   |

각 레지스터는 다음과 같은 정보를 가집니다:
- **Base 레지스터**: 물리적 메모리에서 해당 세그먼트가 시작하는 주소를 저장합니다.
- **Bounds 레지스터**: 해당 세그먼트의 크기를 저장합니다.

#### 3. 주소 변환 예제
가상 주소를 물리 주소로 변환하는 과정을 보겠습니다. **세그멘테이션**에서는 각 세그먼트마다 base와 bounds가 설정되어 있어, 가상 주소는 해당 세그먼트의 base를 기준으로 변환됩니다.

##### 예제 1: 코드 세그먼트 주소 변환
가상 주소 **100**에 접근한다고 가정해 봅시다. 이 주소는 **코드 세그먼트**에 속합니다.

1. **Base 레지스터 값**: `32K`
2. **가상 주소(Virtual Address)**: `100`

주소 변환을 위해 다음 수식을 사용합니다:

$\[
\text{Physical Address} = \text{Base} + \text{Offset}
\]$

여기서 **Offset**은 가상 주소입니다. 따라서:

$\[
\text{Physical Address} = 32K + 100 = 32868
\]$

그리고 이 주소가 세그먼트의 **bounds** 값(2KB) 내에 있는지 확인합니다. 여기서는 `100 < 2KB`이므로 유효한 접근입니다. 따라서 최종적으로 물리 주소 **32868**에 접근합니다.

##### 예제 2: 힙 세그먼트 주소 변환
이번에는 힙 세그먼트의 가상 주소 **4200**에 접근하는 경우를 살펴봅시다.

- **힙의 시작 가상 주소**: `4KB (4096)`
- **Base 레지스터 값**: `34K`
- **가상 주소**: `4200`

먼저, 해당 가상 주소가 힙 세그먼트 내에서의 **Offset**을 구해야 합니다:

$\[
\text{Offset} = \text{가상 주소} - \text{힙의 시작 가상 주소} = 4200 - 4096 = 104
\]$

그 다음, 물리 주소를 계산합니다:

$\[
\text{Physical Address} = \text{Base} + \text{Offset} = 34K + 104 = 34920
\]$

따라서 물리 주소 **34920**에 접근합니다.

#### 4. 잘못된 주소 접근 (Segmentation Fault)
가상 주소 **7KB**에 접근한다고 가정해 보겠습니다. 이 주소는 힙 세그먼트의 끝을 넘어선 잘못된 주소입니다.

- **힙의 크기(bounds)**: `2KB`
- **접근 주소**: `7KB`

하드웨어는 해당 주소가 **bounds**를 초과했음을 감지하고, 이를 운영체제로 트랩합니다. 이러한 상황이 발생하면, 운영체제는 잘못된 프로세스를 종료합니다. 이로 인해 발생하는 오류가 **세그멘테이션 폴트(segmentation fault)**입니다. 이 오류는 메모리 접근이 잘못되었음을 의미하며, 프로그램이 자신의 주소 공간을 벗어나 접근하려고 할 때 발생합니다.

```
가상 주소 (Virtual Address)
+------------------+
| Segment: Code    | -> 가상 주소 100
+------------------+

물리적 메모리 (Physical Memory)
+------------------+
| OS (0K - 16K)    |
+------------------+
| Free (16K - 28K) |
+------------------+
| Stack (28K - 30K)| <- Base: 28K, Size: 2K
+------------------+
| Code (32K - 34K) | <- Base: 32K, Size: 2K
+------------------+
| Heap (34K - 36K) | <- Base: 34K, Size: 2K
+------------------+
| Free (36K - 64K) |
+------------------+
```

## 4.2 세그먼트 종류 파악하기

하드웨어는 변환을 위해 Segment register를 사용한다.
하드웨어는 세그먼트가 어떤 세그먼트인지, 오프셋이 얼마인지 알아야 한다.
이를 위해 가상 주소의 최상위 몇 비트를 기준으로 주소 공간을 여러개의 세그먼트로 나눌 수 있다.
아래 그림을 보도록 하자

![image](https://github.com/user-attachments/assets/db712516-96c4-4e18-b3dc-e668a5141748)

여태까지 예시로는 코드, 힙, 스택 세그먼트만 다루고 있으므로 총 3개가 필요하여 위 그림처럼 세그먼트 비트를 최상위 2비트로 잡았다.
예를 들어, 
- 최상위 비트 2개가 00이라면 코드 세그먼트
- 최상위 비트 2개가 01이라면 힙 세그먼트

만약 가상 주소 공간 4200에 해당하는 물리 주소를 확인해보도록 하자
4200을 이진수로 바꾸면, 아래 그림처럼 나온다.

![image](https://github.com/user-attachments/assets/53251ec5-dfce-4611-acc8-4de7a17ab74d)

그림처럼 최상위 2비트는 힙 영역임을 알 수 있고, 12개의 비트를 10진수로 변환하면 104임을 확인할 수 있다.
이를 base + offset 으로 물리 주소로 변환한다면, 32KB + 104 = 실제 물리 주소를 얻을 수 있다.

## 4.3 스택

스택은 힙 영역과 달리, **반대 방향**으로 확장됩니다.

| Segment | Base | Size |
|---------|------|------|
| Code    | 32K  | 2K   |
| Heap    | 34K  | 2K   |
| Stack   | 28K  | 2K   |

위 표에서 보는 것처럼, 스택의 **Base**가 **28KB**일 때, 스택은 **26KB**까지 확장됩니다. 이는 스택이 **아래 방향(주소 감소)**으로 성장한다는 것을 의미합니다. 가상 주소 공간에서 스택의 주소 범위는 **16KB에서 14KB**로 설정되어 있습니다.

이 연산을 위해 하드웨어는 **세그먼트가 어느 방향으로 확장하는지** 알아야 하며, 이를 위해 하나의 비트(1이면 주소가 증가하는 방향, 0이면 주소가 감소하는 방향)를 사용해야 합니다.

### 주소 변환 예제

만약, 가상 주소 **15KB**에 접근하려고 한다면, 이 주소는 물리 주소 **27KB**에 매핑되어야 합니다. 이 과정을 살펴보겠습니다.

1. **가상 주소 15KB**를 이진수로 표현하면:
   - `11 1100 0000 0000` (16진수 `0x3C00`)

2. 하드웨어는 **상위 2비트** (`11`)를 사용하여 세그먼트를 결정합니다. 여기서는 **스택 세그먼트**임을 알 수 있습니다. 나머지 비트(`1100 0000 0000`)는 **오프셋(offset)**을 나타냅니다.
   - 이 오프셋은 **3KB**를 의미합니다.

3. 스택이 **아래 방향으로 성장**하기 때문에, **올바른 음수 오프셋**을 얻기 위해서는 최대 세그먼트 크기에서 오프셋을 빼주어야 합니다.
   - 최대 세그먼트 크기는 **4KB**로 가정하므로, `3KB - 4KB = -1KB`가 됩니다.

4. 최종적으로, **Base 레지스터 값(28KB)**에 **음수 오프셋(-1KB)**을 더해 물리 주소를 계산합니다.
   $\[
   \text{Physical Address} = 28KB + (-1KB) = 27KB
   \]$

따라서 **물리 주소 27KB**에 접근하게 됩니다.

## 4.4 Support for Sharing

세그멘테이션 관리 기법이 발전하면서, **세그먼트 공유**를 통해 메모리를 더 효율적으로 사용할 수 있다는 것을 발견했습니다.

- 특히 **코드 세그먼트(Code segment)**를 공유하는 것은 메모리 사용을 최적화하는 데 매우 유용합니다. 여러 프로세스가 같은 코드를 실행할 경우, 별도의 코드 세그먼트를 할당하기보다는 **동일한 코드 세그먼트**를 사용하는 것이 효율적입니다.

### Protection bits

**Sharing** 기능을 지원하기 위해서 **보호 비트(protection bits)**가 도입되었습니다. 보호 비트는 세그먼트별로 접근 권한을 설정하기 위해 몇 가지 정보를 추가로 저장합니다. 예를 들어, **읽기(Read)**, **쓰기(Write)**, **실행(Execute)** 권한을 설정하여 각 세그먼트에 대한 접근을 제어합니다.

![image](https://github.com/user-attachments/assets/8c889a56-f009-4aa2-9185-a7e5f2e11468)

- 예를 들어, 코드 세그먼트를 **읽기-실행(Read-Execute)**으로 설정하면, 여러 프로세스가 동일한 코드 세그먼트를 공유하더라도 고립성(isolation)에 문제가 발생하지 않으며, 동일한 내용을 안전하게 실행할 수 있습니다.
- 반면, **Heap**과 **Stack**은 **읽기-쓰기(Read-Write)** 권한을 가집니다. 이는 힙과 스택 영역이 각 프로세스에서 독립적으로 사용되며, 실행 중에 변경될 수 있기 때문입니다.

### 물리적 메모리 예시

다음은 세그멘테이션을 사용하여 물리적 메모리에 세그먼트를 배치하고, **코드 세그먼트를 공유**하는 구조를 보여줍니다.

```
물리적 메모리 (Physical Memory)
+------------------+
| OS (0K - 16K)    |
+------------------+
| Free (16K - 28K) |
+------------------+
| Code (32K - 34K) | <- 여러 프로세스가 공유 (Protection: Read-Execute)
+------------------+
| Heap (34K - 36K) | <- 각 프로세스가 독립적으로 사용 (Protection: Read-Write)
+------------------+
| Stack (28K - 30K)| <- 각 프로세스가 독립적으로 사용 (Protection: Read-Write)
+------------------+
| Free (36K - 64K) |
+------------------+
```

## 4.5 OS Support

세그멘테이션 기법은 단일 base/bound 레지스터를 사용하는 방법에 비해, 논리적 세그먼트마다 base와 bound 레지스터를 사용하여 물리적 메모리의 낭비를 줄일 수 있습니다. 이를 통해 물리적 메모리 공간의 효율성을 높이는 것이 가능합니다.

하지만, 세그멘테이션 도입 시 몇 가지 문제가 새롭게 발생합니다.

### 1. Context switch
세그멘테이션 기법을 도입하면, 가상 주소 공간의 세그먼트들이 물리적 메모리에 연속적으로 배치되지 않고, 각 세그먼트가 떨어져서 배치됩니다. 이 경우 **컨텍스트 스위치**가 발생할 때 각 프로세스의 **세그먼트 레지스터** 값을 저장하고 복원해야 합니다. 이를 통해 운영체제는 프로세스가 올바르게 메모리에 접근할 수 있도록 보장합니다.

### 2. Managing free space
세그멘테이션 도입 시 **물리적 메모리에서의 자유 공간 관리** 문제가 발생합니다. 이전에는 물리적 메모리를 고정된 크기의 슬롯으로 나누어 각 프로세스를 배치하는 방식이 사용되었지만, 세그멘테이션은 각 세그먼트를 서로 다른 위치에 배치할 수 있으므로, **외부 단편화(external fragmentation)** 문제가 발생합니다. 이는 물리적 메모리 중 사용되지 않는 작은 공간들이 여러 곳에 나뉘어 생기며, 연속된 큰 공간을 할당할 수 없는 상황을 만듭니다.

![image](https://github.com/user-attachments/assets/b9883af1-d853-43ea-8e22-aa87ab2a35f0)

예를 들어, 물리적 메모리에 **24KB**의 자유 공간이 있지만, 이는 연속적이지 않은 작은 조각들로 나뉘어 있어, **20KB**의 새로운 세그먼트를 할당하지 못하는 상황이 발생할 수 있습니다.

### Compaction
- 이를 해결하기 위해 **메모리 압축(compaction)**을 수행할 수 있습니다.
- 메모리 압축은 기존 세그먼트들을 재배치하여 큰 연속된 자유 공간을 확보하는 방법입니다.
- 하지만, 이 과정은 실행 중인 프로세스를 모두 중지하고, 각 세그먼트의 주소를 새로 설정해야 하므로 많은 시간과 비용이 듭니다.

### Free list management
- **Free list 관리 알고리즘**을 사용하면 외부 단편화를 줄이고 보다 효율적으로 메모리를 사용할 수 있습니다.
- 이 방법은 외부 단편화를 완전히 해결하지는 못하지만, 메모리 압축에 비해 실시간 시스템에서 사용하기 적합합니다.
- 대표적인 알고리즘에는 다음이 있습니다:
  1. **Best fit**: 필요한 크기와 가장 가까운 크기의 공간을 할당하여, 공간 낭비를 줄이는 방법. 그러나 작은 조각들이 남아 외부 단편화 발생 가능성이 있습니다.
  2. **Worst fit**: 가장 큰 자유 공간을 할당하여 큰 블록을 남기는 방식. 그러나 메모리 사용의 효율성이 떨어질 수 있습니다.
  3. **First fit**: 할당할 공간을 처음 찾은 위치에 할당하여 검색 속도를 빠르게 하는 방법. 초기 메모리 부분에 단편화가 발생할 수 있습니다.
  4. **Buddy algorithm**: 메모리를 크기 `2^n`으로 나누어 필요한 크기에 맞게 할당하는 방식. 관리가 용이하지만 크기 제한으로 인해 일부 메모리 낭비가 발생할 수 있습니다.


