# 메모리를 어떻게 효율적이고 유연하게 가상화할 수 있을까?

## 주소 변환 메커니즘 - 하드웨어 기반 주소 변환

- 주소 변환을 통해 프로세스마다 가지고 있는 가상 주소 공간에 있는 가상 주소에 대해 실제 물리적 주소로 변환하는것임
- 다시 말해, 메모리 참조가 있을 떄 마다 하드웨어가 주소 변환(CPU의 MMU가 수행)을 수행해서 실제 메모리 위치로 참조를 제공함

## 3.1 가정

> 가정사항
> - 일단 모든 프로세스들이 사용하는 가상 주소 공간은 실제 물리 메모리에 연속되어 저장되어 있다고 가정한다.
> - 다시 말해, 하나의 프로세스에서 사용하는 가상 주소 공간이 실제 물리 메모리에 파편화되어 있지 않다고 생각하면 된다.
> - 또한, 가상 주소 공간은 실제 물리 메모리 크기보다 작다고 가정한다.

## 3.2 예시

```c
void func(){
  int x = 3000;
  x = x + 3;
}
```

```assembly
128: mov; 0x0(%ebx), %eax; 0 + ebx 레지스터에서 값을 불러와서 eax(범용 레지스터)에 저장
132: addl $0x03, %eax; eax 레지스터에 3을 더한다.
136: mov; %eax, 0x0(%ebs); eax를 다시 같은 위치인 ebs로 되돌려 놓는다.
```

![image](https://github.com/user-attachments/assets/ae880e3f-79f0-4d94-bc51-e511d9f8b894)
위 그림처럼, 세개의 명령어 코드는 Text 영역에 존재하며, 3000이라는 값은 stack 영역에 존재하는것을 볼 수 있다.
또한, 가상 주소 공간의 크기가 16KB라면, 프로세스에서 사용하는 모든 가상 주소에 대한 메모리 참조는 0~16KB 내에 존재한다.

- **하지만 가상 메모리 주소가 아니라, 실제 메모리 주소를 사용해야 하는데, 프로세스를 물리적 메모리에 배치해야 한다.**
- **프로세스를 실제 물리 메모리에 배치할 때 항상 0번지부터 시작하는게 아니다**

![image](https://github.com/user-attachments/assets/052dd141-cf5a-4d51-9239-831e8c778c55)
- 이 그림은 실제 메모리에 가상 주소 공간에 대한 정보가 담긴 모습이다.
- **실제 물리 메모리의 어딘가에 배치되더라도, 프로세스 본인은 자기는 0번지부터 시작하는 주소 공간을 가지고 있다고 생각하게 된다. (가상화)**

## 3.3 하드웨어 기반 재배치 (동적 재배치)

하드웨어 기반 재배치는 CPU가 수행을 하는데, 그 중 두개의 레지스터가 필요하다.
**1. base register**
**2. limit register**

> 이 레지스터들을 사용해서 프로세스의 가상 주소 공간에 대응하는 물리적 주소 공간을 어디에나 배치할 수 있다.

### 가상 주소를 물리적 주소로 변환하는 방식

> 물리적 주소 = 가상 주소 + base register 값

**Example**

![image](https://github.com/user-attachments/assets/052dd141-cf5a-4d51-9239-831e8c778c55)

```assembly
128: mov; 0x0(%ebx), %eax;
```

위 그림을 보면, base register는 32KB = 32768이다. (1KB = 1024 Byte 이므로) 
이 명령어에서 PC가 128일때, CPU는 가상 주소인 128 + 32768 = **32896** = 실제 물리 주소
실제로 하드웨어가 32896번지에서 명령어를 가져온다.

### Limit register

> Limit register는 보호와 관련이 있다.

- CPU는 먼저 가상 주소가 Bound 안에 있는지 확인해야 한다. (예시에서는 0 ~ 16KB 사이에 있는지)
- 만약 프로세스가 Bound보다 크거나 작은 주소를 참조한다면, CPU가 예외를 발생시키고 종료시켜버린다.

> 이러한 레지스터들을 관리하는 프로세서를 MMU라고 한다.

### Example

예를 들어, 가상 주소 공간 크기가 **4KB**이고, 실제 물리 메모리의 **16KB**에 저장되었다고 했을 때, (앞에서 가정했으니까 연속되어 존재함)
- 가상 주소 0 이면 실제 물리 주소 = 0 + 16KB = 16KB
- 가상 주소 1KB -> 실제 물리 주소 = 1KB + 16KB = 17KB
- 가상 주소 3000 = 2~3KB 이므로 -> 실제 물리 주소는 약 18~19KB
**- 가상 주소 4400 = 4KB를 넘어감 -> limit register를 초과하므로 에러가 발생한다**

### 하드웨어 기반 재배치를 위한 하드웨어 지원 기능

![image](https://github.com/user-attachments/assets/f28f5233-7496-40d1-b4e7-a1bf171bb72d)

## 3.4 운영체제 이슈

OS의 메모리 가상화에서 base, bound 레지스터를 사용해서 가상 메모리를 구현하기 위해서는 몇가지 해결해야할 요소가 있다.

### 1. 프로세스 생성 시 OS는 해당 프로세스의 주소 공간을 메모리 내에서 찾아야 한다.
- OS는 새로운 프로세스 생성 시 비어 있는 공간을 찾기 위해 "Free list"라 불리는 자료구조를 탐색해서, 새로운 주소 공간을 위한 공간을 확보하고, 사용 중으로 표시한다.

### 2. 프로세스 종료 시 OS는 해당 프로세스의 메모리를 회수해서 다른 프로세스나 OS가 사용할 수 있도록 해야한다.

### 3. Context switching이 발생할 때 OS가 적절한 조치를 취해야 한다.
- 프로세스 간 전환 시 base와 bounds 레지스터의 값을 따로 저장하고, 나중에 다시 프로세스를 가져와 실행할 때 이 값을 가져와야 한다.
- 왜냐하면 프로세스마다 base와 bounds값이 각각 다르기 때문이다. (즉, 기존에 어디서부터 실행해야 할지 각 프로세스마다 다름)
- 이를 메모리에 저장하게 되는데 주로 **proc 구조체를 사용해서 저장한다.**

### 내부 단편화 (internal fragmentation)
![image](https://github.com/user-attachments/assets/d625bd6f-1428-4f53-92e3-a843ab423b41)
그림과 같이 32KB ~ 48KB까지의 물리적 메모리를 사용하고 있지만, 할당된 공간에서 Heap과 Stack이 차지하는 영역이 크지 않아서 내부 단편화 (쓰지 않는 영역)이 발생하는것을 볼 수 있다.

