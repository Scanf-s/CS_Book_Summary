# 메모리를 어떻게 효율적이고 유연하게 가상화할 수 있을까?

## 주소 변환 메커니즘 - 하드웨어 기반 주소 변환

- 주소 변환을 통해 프로세스마다 가지고 있는 가상 주소 공간에 있는 가상 주소에 대해 실제 물리적 주소로 변환하는것임
- 다시 말해, 메모리 참조가 있을 떄 마다 하드웨어가 주소 변환(CPU의 MMU가 수행)을 수행해서 실제 메모리 위치로 참조를 제공함

## 3.1 가정

> 가정사항
> - 일단 모든 프로세스들이 사용하는 가상 주소 공간은 실제 물리 메모리에 연속되어 저장되어 있다고 가정한다.
> - 다시 말해, 하나의 프로세스에서 사용하는 가상 주소 공간이 실제 물리 메모리에 파편화되어 있지 않다고 생각하면 된다.
> - 또한, 가상 주소 공간은 실제 물리 메모리 크기보다 작다고 가정한다.

## 3.2 예시

```c
void func(){
  int x = 3000;
  x = x + 3;
}
```

```assembly
128: mov; 0x0(%ebx), %eax; 0 + ebx 레지스터에서 값을 불러와서 eax(범용 레지스터)에 저장
132: addl $0x03, %eax; eax 레지스터에 3을 더한다.
136: mov; %eax, 0x0(%ebs); eax를 다시 같은 위치인 ebs로 되돌려 놓는다.
```

![image](https://github.com/user-attachments/assets/ae880e3f-79f0-4d94-bc51-e511d9f8b894)
위 그림처럼, 세개의 명령어 코드는 Text 영역에 존재하며, 3000이라는 값은 stack 영역에 존재하는것을 볼 수 있다.
또한, 가상 주소 공간의 크기가 16KB라면, 프로세스에서 사용하는 모든 가상 주소에 대한 메모리 참조는 0~16KB 내에 존재한다.

- **하지만 가상 메모리 주소가 아니라, 실제 메모리 주소를 사용해야 하는데, 프로세스를 물리적 메모리에 배치해야 한다.**
- **프로세스를 실제 물리 메모리에 배치할 때 항상 0번지부터 시작하는게 아니다**

![image](https://github.com/user-attachments/assets/052dd141-cf5a-4d51-9239-831e8c778c55)
- 이 그림은 실제 메모리에 가상 주소 공간에 대한 정보가 담긴 모습이다.
- **실제 물리 메모리의 어딘가에 배치되더라도, 프로세스 본인은 자기는 0번지부터 시작하는 주소 공간을 가지고 있다고 생각하게 된다. (가상화)**

## 3.3 하드웨어 기반 재배치 (동적 재배치)

하드웨어 기반 재배치는 CPU가 수행을 하는데, 그 중 두개의 레지스터가 필요하다.
**1. base register**
**2. limit register**

> 이 레지스터들을 사용해서 프로세스의 가상 주소 공간에 대응하는 물리적 주소 공간을 어디에나 배치할 수 있다.

### 가상 주소를 물리적 주소로 변환하는 방식

> 물리적 주소 = 가상 주소 + base register 값

**Example**

![image](https://github.com/user-attachments/assets/052dd141-cf5a-4d51-9239-831e8c778c55)

```assembly
128: mov; 0x0(%ebx), %eax;
```

위 그림을 보면, base register는 32KB = 32768이다. (1KB = 1024 Byte 이므로) 
이 명령어에서 PC가 128일때, CPU는 가상 주소인 128 + 32768 = **32896** = 실제 물리 주소
실제로 하드웨어가 32896번지에서 명령어를 가져온다.

### Limit register

> Limit register는 보호와 관련이 있다.

- CPU는 먼저 가상 주소가 Bound 안에 있는지 확인해야 한다. (예시에서는 0 ~ 16KB 사이에 있는지)
- 만약 프로세스가 Bound보다 크거나 작은 주소를 참조한다면, CPU가 예외를 발생시키고 종료시켜버린다.

> 이러한 레지스터들을 관리하는 프로세서를 MMU라고 한다.

### Example

예를 들어, 가상 주소 공간 크기가 **4KB**이고, 실제 물리 메모리의 **16KB**에 저장되었다고 했을 때, (앞에서 가정했으니까 연속되어 존재함)
- 가상 주소 0 이면 실제 물리 주소 = 0 + 16KB = 16KB
- 가상 주소 1KB -> 실제 물리 주소 = 1KB + 16KB = 17KB
- 가상 주소 3000 = 2~3KB 이므로 -> 실제 물리 주소는 약 18~19KB
**- 가상 주소 4400 = 4KB를 넘어감 -> limit register를 초과하므로 에러가 발생한다**

### 하드웨어 기반 재배치를 위한 하드웨어 지원 기능

![image](https://github.com/user-attachments/assets/f28f5233-7496-40d1-b4e7-a1bf171bb72d)
