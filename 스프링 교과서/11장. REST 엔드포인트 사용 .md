백엔드를 모놀리식 아키텍쳐가 아니라 마이크로 서비스 아키텍쳐로 개발하면 하나의 백엔드 인스턴스에서 다른 백엔드 인스턴스로 API를 호출하는 경우가 자주 있다. 따라서 다른 백엔드 인스턴스의 API를 호출하기 위해 11장에서 설명하는 방법을 알아야 한다.

스프링에서는 REST API를 호출할 때 다음 세 가지 방법으로 수행한다.

> 1. **OpenFeign** : 책에서 가장 권하는 방법이다
2. **RestTemplate** : Deprecated지만, 사용 방법은 알아놓아야 한다.
3. **WebClient** : Spring에서 RestTemplate 대신 사용을 권하는 방법이다. 그러나 책에서 WebClient의 단점을 소개하고, OpenFeign을 권장하는 이유를 설명한다.

### 시나리오

![](https://velog.velcdn.com/images/calzone0404/post/0a8ce2cc-c1c5-4833-816a-aaa0c40bc3c9/image.jpg)

즉, 로컬에서 백엔드 앱, 결제 서비스 앱 총 2개의 프로젝트를 띄워서 실습하게 된다.

### 결제 서비스 앱

결제 서비스 앱은 단순하다. 그냥 POST 요청이 들어오면 단순히 그림에 있는 JSON 형식(맨 오른쪽에 있는거)을 반환해주는 Controller만 있으면 된다.

```java
// Payment Service APP
@RestController
public class PaymentsController {
	private static Logger logger = Logger.getLogger(PaymentsController.class.getName()); // 로그 찍으려고 사용
    
    @PostMapping("/payment")
    public ResponseEntity<Payment> createPayment(
    	@RequestHeader String requestId,
        @RequestBody Payment payment
    ) {
    	logger.info("요청 : " + requestId + " " + "payment.getAmount()");
        payment.setId(UUID,randomUUID().toString()); // UUID 설정
        return ResponseEntity
        		.status(HttpStatus.OK)
                .header("requestId", requestId)
                .body(payment);
    }
}
```

Payment 모델은 적절히 구현해주면 된다.

그리고 로컬 컴퓨터에서 이걸 실행하면 결제 시스템 앱은 8080번 포트를 점유하게 되는데, 다른 앱을 또 생성하게 되면 충돌이 나게 되므로 프론트로부터 요청을 전달받는 스프링 앱은 8081 포트를 사용하였다. (클라우드 환경에서 인스턴스 여러개 띄워서 테스트한다면 따로 설정해줄 필요 X)

# 11.1 스프링 클라우드 OpenFeign으로 REST 엔드포인트 호출하기

## OpenFeign

(설명 추가해야함)

## Architecture

![](https://velog.velcdn.com/images/calzone0404/post/038285b2-dcd7-49c1-b882-21a77b8840c6/image.png)


## Order Service

> 주문 시스템은 프론트측으로부터 직접적으로 호출을 받는 백엔드 어플리케이션이다.

### 1. Model 설정

#### OrderRequest

> Client측이 요청할 때 필요한 필드를 정의한 모델 클래스

```java
package com.sullung.springrestapi.models;

public class OrderRequest {
    private double amount;

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }
}
```

#### PaymentRequest

> Payment Service로 요청을 보낼 때 사용할 모델 클래스

```java
package com.sullung.springrestapi.models;

import java.util.UUID;

public class PaymentRequest {

    private String requestId;
    private double amount;

    public PaymentRequest(double amount) {
        this.requestId = UUID.randomUUID().toString();
        this.amount = amount;
    }

    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }
}
```

#### PaymentResponse

> Payment 서비스가 전달하는 데이터를 받을 모델 클래스
필자는 success field에 @JsonProperty를 붙였는데, 이걸 안붙이면 Payment 서비스가 전달해주는 success field를 인식하지 못해서 추가해주었다.

```java
package com.sullung.springrestapi.models;

import com.fasterxml.jackson.annotation.JsonProperty;

public class PaymentResponse {

    @JsonProperty("success")
    private boolean success;

    public PaymentResponse() {
    }

    public PaymentResponse(boolean success) {
        this.success = success;
    }

    public boolean isSuccessful() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    @Override
    public String toString() {
        return "PaymentResponse{" +
                "success=" + success +
                '}';
    }
}
```

### 2. Controller 설정

#### OrderController

> Client가 /api/v1/orders/checkout endpoint로 요청해야 한다. 요청 시 amount 값이 필요하다.

```java
@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {

    private final OrderService orderService;

    @Autowired
    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping("/checkout")
    public ResponseEntity<String> createOrder(@RequestBody OrderRequest orderRequest) {
        String response = orderService.createOrder(orderRequest);

        if (response.contains("failed")) {
            return ResponseEntity.badRequest().body(response);
        }
        return ResponseEntity.ok(response);
    }
}
```

### 3. Service 설정

#### OrderService

```java
@Service
public class OrderService {

    private final PaymentProxy paymentProxy;

    @Autowired
    public OrderService(PaymentProxy paymentProxy) {
        this.paymentProxy = paymentProxy;
    }

    public String createOrder(OrderRequest orderRequest) {
        // 결제 요청
        PaymentRequest paymentRequest = new PaymentRequest(orderRequest.getAmount());
        System.out.println("Try to create order with amount: " + orderRequest.getAmount());
        PaymentResponse paymentResponse = paymentProxy.processPayment(paymentRequest); // Payment로 요청을 보낸다.
        System.out.println(paymentResponse);

        if (paymentResponse.isSuccessful()) {
            // 결제가 성공했을 때
            return "Order created and payment successful!";
        } else {
            // 결제가 실패했을 때
            return "Order creation failed due to payment error.";
        }
    }
}
```

### 4. Proxy 설정

> Payment와 통신해야 하기 때문에 OpenFeign Client를 만들어야 한다.

```java
// 로컬에서 두개를 띄워야 하므로 payment는 8081번으로 띄웠다.
@FeignClient(name = "payment-service", url="http://127.0.0.1:8081")
public interface PaymentProxy {

    @PostMapping("/api/v1/payments") // Payment의 /api/v1/payments로 요청을 보낸다.
    PaymentResponse processPayment(@RequestBody PaymentRequest paymentRequest); // 이걸 그대로 Payment의 controller에서 구현하면 된다.
}
```

### 5. OpenFeign 사용 명시

> Main 클래스에서 OpenFeign을 사용한다고 명시해야한다.

```java
@SpringBootApplication
@EnableFeignClients
public class SpringRestApiApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringRestApiApplication.class, args);
    }
}
```

## Payment Service

> Order 백엔드 어플리케이션으로부터 요청을 받아서 결제를 처리하고, 결과를 전달해주는 어플리케이션 이다.

### 1. Model 설정

#### PaymentRequest

> Order로부터 들어오는 항목에 대한 모델 클래스이다. Order와 동일하게 작성하면 된다.

#### PaymentResponse

> Order에게 전달하는 항목에 대한 모델 클래스이다. Order와 동일하게 작성하면 된다.

### 2. Controller

```java
@RestController
@RequestMapping("/api/v1/payments")
public class PaymentController {
    @PostMapping
    public PaymentResponse processPayment(@RequestBody PaymentRequest paymentRequest) {
        // 실제 결제 처리 로직이 들어가는 부분
        boolean paymentSuccessful = processPaymentLogic(paymentRequest.getAmount());
        System.out.println("Payment successful: " + paymentSuccessful);

        PaymentResponse response = new PaymentResponse(paymentSuccessful);
        System.out.println(response);
        // 결제 성공 여부를 기반으로 PaymentResponse 반환
        return response;
    }

    // 간단한 결제 처리 로직을 모의하는 메서드
    private boolean processPaymentLogic(double amount) {
        // 실제 로직에서는 결제 게이트웨이와의 통신 등이 포함될 수 있음
        // 여기서는 간단하게 임의의 조건을 넣음
        return amount > 0 && amount < 1000;  // 예를 들어, 금액이 1000 이하일 때만 성공
    }
}
```

## 실행 결과

![](https://velog.velcdn.com/images/calzone0404/post/74bf9129-60d0-43a9-928e-4ba29b40c034/image.png)

# 11.2 RestTemplate으로 REST 엔드포인트 호출하기

# 11.3 WebClient로 REST 엔드포인트 호출하기

