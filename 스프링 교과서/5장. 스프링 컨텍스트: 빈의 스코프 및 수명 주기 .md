# 5.1 싱글톤 빈 스코프

> 스프링 프레임워크에서 빈(Bean)을 관리하는 가장 기본적인 방식 : 싱글톤 빈 스코프 방식

## 5.1.1 싱글톤 빈 작동 방식

스프링에서 지금까지 우리가 사용해 온 빈 생성 방식은 모두 싱글톤 패턴을 따릅니다. 컴포넌트 스캔을 통해 빈을 등록하거나 @Bean 어노테이션을 사용하여 빈을 등록하는 방식 모두 기본적으로 싱글톤 빈을 생성합니다.

#### 일반적인 싱글톤 패턴

일반적인 싱글톤 패턴은 특정 클래스의 인스턴스가 메모리상에 오직 하나만 존재하도록 보장하는 디자인 패턴입니다. 이는 애플리케이션의 전체 메모리 영역에서 해당 클래스의 인스턴스가 단 하나만 생성됨을 의미합니다.

#### 스프링에서의 싱글톤 스코프

스프링의 싱글톤 스코프는 일반적인 싱글톤 패턴의 개념을 확장합니다. 스프링 컨텍스트에서 싱글톤 스코프는 특정 이름(빈 이름 또는 메서드 이름)에 대해 동일한 인스턴스를 의미합니다. 이는 스프링 컨텍스트 내에서 같은 이름의 빈을 요청할 때마다 항상 동일한 객체 인스턴스가 반환됨을 뜻합니다.

주목할 점은, 스프링에서는 같은 클래스 타입이라도 다른 이름으로 등록된 빈들은 서로 다른 인스턴스일 수 있다는 것입니다. 이는 일반적인 싱글톤 패턴과는 다른 스프링만의 특징입니다.

### @Bean을 사용한 싱글톤 스코프 빈 선언

@Bean 어노테이션을 사용하여 빈을 선언할 때, 해당 빈은 기본적으로 싱글톤 스코프로 생성됩니다. 다음은 그 예시입니다:

```java
@Configuration
public class ProjectConfig {
    @Bean 
    public CommentService commentService() {
        return new CommentService();
    }
}
```

이렇게 선언된 빈은 스프링 컨텍스트에서 항상 같은 인스턴스를 반환합니다:

```java
public static void main(String[] args) {
    var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
    var service1 = context.getBean("commentService", CommentService.class);
    var service2 = context.getBean("commentService", CommentService.class);
    
    boolean isSameInstance = (service1 == service2);
    System.out.println(isSameInstance);  // 출력: true
}
```

### 컴포넌트 스캔 방식의 싱글톤 스코프 빈 선언

@Component, @Service, @Repository 등의 스테레오타입 어노테이션을 사용하여 빈을 선언할 때도 마찬가지로 싱글톤 스코프로 생성됩니다. 예를 들어:

```java
@Service
public class CommentService {
    @Autowired
    private CommentRepository repo;
    
    public CommentRepository getCommentRepo() {
        return this.repo;
    }
}

@Service
public class UserService {
    @Autowired
    private CommentRepository repo;
    
    public CommentRepository getCommentRepo() {
        return this.repo;
    }
}

@Repository
public class CommentRepository {
    // 구현 내용
}

@Configuration
@ComponentScan(basePackages = {"com.example"})
public class ProjectConfig {}
```

이 경우, CommentService와 UserService는 같은 CommentRepository 인스턴스를 공유합니다:

```java
public static void main(String[] args) {
    var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
    var commentService = context.getBean(CommentService.class);
    var userService = context.getBean(UserService.class);
    
    boolean isSameRepo = (commentService.getCommentRepo() == userService.getCommentRepo());
    System.out.println(isSameRepo);  // 출력: true
}
```

## 5.1.2 실제 시나리오의 싱글톤 빈

싱글톤 빈을 사용할 때는 몇 가지 중요한 고려사항이 있습니다:

1. **불변성(Immutability)**: 싱글톤 빈은 가능한 한 불변이어야 합니다. 여러 스레드가 동시에 같은 빈 인스턴스에 접근할 때 발생할 수 있는 동시성 문제를 방지하기 위해서입니다.

2. **생성자 주입 사용**: 필드 주입 대신 생성자 주입을 사용하면 빈의 필드를 final로 선언할 수 있어 불변성을 보장할 수 있습니다.

   ```java
   @Service
   public class CommentService {
       private final CommentRepository repo;
       
       @Autowired
       public CommentService(CommentRepository repo) {
           this.repo = repo;
       }
   }
   ```

3. **스프링 기능이 불필요한 경우**: 스프링 프레임워크의 기능이 필요 없는 단순한 객체라면 빈으로 등록할 필요가 없습니다.

4. **가변 상태가 필요한 경우**: 빈의 상태가 변경 가능해야 한다면, 싱글톤 스코프 대신 프로토타입 스코프를 고려해 볼 수 있습니다.

싱글톤 빈을 사용할 때는 **항상 스레드 안전성을 고려**해야 합니다. 가능한 한 상태를 갖지 않는 stateless 빈을 만들거나, 필요한 경우 적절한 동기화 메커니즘을 사용해야 합니다.

## 5.1.3 즉시 및 지연 인스턴스 생성 방식

### 즉시 인스턴스 생성 방식

### 지연 인스턴스 생성 방식

### 그렇다면 어떤 상황에서 뭘 사용해야할까?

# 5.2 프로토타입 빈 스코프
